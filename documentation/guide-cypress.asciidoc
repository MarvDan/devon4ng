:toc: macro

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

toc::[]
:idprefix:
:idseparator: -
:reproducible:
:source-highlighter: rouge
:listing-caption: Listing

= Testing e2e with Cypress

This guide will cover the basics of e2e testing using Cypress.

Cypress is a framework “all in one” that provides the necessary libraries to write specific e2e tests, without the need of Selenium.

Why Cypress?
* Uses javascript
* It works directly with the browser so the compatibility with the frontend framework the project uses (in this case Angular) is not a problem.
* Easy cross browser testing

== Files / Structure
[source,ts]
/cypress
  /fixtures
    - example.json
  /integration
    - button.spec.ts
  /plugins
    - index.js
  /support
    - commands.js
    - index.js


== Tests
First we define a context to group all our test refered to the same subject

[source,ts]
context('Button page', () => {
  beforeEach(() => {
    cy.visit('/');
  });
  it('should have button',()=>{
    cy.get('button').should('exist');
  });
  it('should contain 'PRESS',()=>{
    cy.contains('button', 'PRESS');
  });
});

The structure is the same than Mocha.

.beforeEach
Visit '/' before every test.

.it
Inside we write the test steps.

For more info check link:docs.cypress.io/guides/core-concepts/writing-and-organizing-tests.html#Folder-Structure[Cypress documentation]

== Fixtures

We use fixtures to mock data, it can be a json, an img, video...
---
{
  "name": "Dummy name",
  "phone": 999 99 99 99,
  "body": "Mock data"
}
---
You can store multiple mocks on the same fixture file

[source,ts]
---
{
  "create":{"name": "e2etestBox"},
  "boxFruit":{
    "uuid":"3376339576e33dfb9145362426a33333",
    "name":"e2etestBox",
    "visibility":true,
    "items":[
      {"name":"apple","units":3},
      {"name":"kiwi","units":2},
    ]
  },
}
---

To access data we don't need to import any file, we just call cy.fixture + the name file.
We can name it as we want.

[source,ts]
cy.fixture('box.json').as('fruitBox')

== Request / Route

With cypress you can test your aplication with real data or with mocks.

Not using mocks guarantees that your tests are real e2e test but makes them vulnerable to external issues.
When you mock data you don't know exactly if the data and structure recibed from de backend is correct because you are forcing a mock on the response,
but you can avoid external issues, run test faster and have better control on the structure and status.

=== Route

Cypress can intercept a XHR request and interact with it.

[source,ts]
cy.server();
cy.route(
  'GET',
  '/apiUrl/list',
  [{"name":"apple", "units":3},{"name":"kiwi", "units":2}]
)

_cy.server(options)_ start a server to interact with the responses.

_cy.route(options)_ intercepts a XMLHttpRequests
*method* GET
.*url* '/apiUrl/list'
.*respones* [{"name":"apple", "units":3},{"name":"kiwi", "units":2}]

*Waits*
Every cypress action has a default await time to avoid asyncronous issues, but this time can be short for
some particular actions like api calls, for those cases we can use *cy.wait()*

[source,ts]
---
cy.server();
cy.route('/apiUrl/list').as('list');
cy.visit('/boxList');
cy.wait('@list');
---

To mock data with fixtures:

[source,ts]
---
cy.fixture('box')
  .then(({boxFruit}) => {
    cy.route(
      'GET',
      '/apiUrl/list',
      boxFruit
    ).as('boxFruit');
    cy.get('#button').click();
    cy.wait('@journalsList');
    cy.get('#list').contains('apple');
  })
---

We get boxFruit data form the box fixture and then we mock the api call with it so now the response of the call is boxFruit object.
When the button is clicked, it waits to recibe the response of the call and then checks if the list 
contains one of the elements of the fruitBox.

To get more information check link:https://docs.cypress.io/guides/guides/network-requests.html#Testing-Strategies[cy network route documentation]

=== Request
Make a HTTP request.

[source,ts]
cy.server();
cy.request('http://localhost:4200/').its('body').should('include', '<h1>Welcome to Devon4ngAngularElementsTest!</h1>');

If we have _http://localhost:4200_ as baseUrl on _cypress.json_

[source,ts]
cy.server();
cy.request('/').its('body').should('include', '<h1>Welcome to Devon4ngAngularElementsTest!</h1>');
// Goes to http://localhost:4200/

We can add other options

[source,ts]
cy.server();
cy.request({
  method: 'POST',
  url: '/send',
  form: true,
  body: {
    name: 'name task',
    description: 'description of the task'
  }
});


== Custom comands

If you see yourself writting the same test more than once, you can create a custom command to make things
faster.

**commands.ts**
[source,ts]
Cypress.Commands.add('checkPlaceholder', (name) => {
  cy.get(`[name=${name}]`)
    .click()
    .then(()=>{
      cy.get(`[name=${name}]`).should('have','class','mat-focused');
    })
})

**index.ts**

For using the commands we need to import the files on index.ts

[source,ts]
import './commands'
import './file1'
import './folder/file2'



**index.d.ts**

[source,ts]
declare namespace Cypress {
  interface Chainable<Subject> {
    checkPlaceholder(name:string):Chainable<void>
  }
}

== Reporter